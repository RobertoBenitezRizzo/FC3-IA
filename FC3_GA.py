# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EhkqAe1qIDxj3gmn6yj-DMrUx-UaD6sN
"""

import random
import numpy as np
from copy import deepcopy

# Defines 5 nodes in the distributed system, each with specific resource capacities (CPU cores, memory in GB, and bandwidth in Mbps)
nodes = {
    1: {'cpu': 8, 'memory': 16, 'bandwidth': 100},
    2: {'cpu': 4, 'memory': 32, 'bandwidth': 50},
    3: {'cpu': 16, 'memory': 8, 'bandwidth': 200},
    4: {'cpu': 12, 'memory': 24, 'bandwidth': 150},
    5: {'cpu': 6, 'memory': 12, 'bandwidth': 80}
}

# Defines the maximum percentage of each resource a node is allowed to use
resource_limits = {
    'cpu': 0.8,
    'memory': 0.9,
    'bandwidth': 0.75
}

# Defines 10 tasks with required CPU, memory, and bandwidth, and their execution time on each node
tasks = {
    1: {'cpu': 2, 'memory': 4, 'bandwidth': 30, 'execution_time': {1: 10, 2: 15, 3: 8, 4: 12, 5: 14}},
    2: {'cpu': 4, 'memory': 8, 'bandwidth': 20, 'execution_time': {1: 12, 2: 20, 3: 10, 4: 15, 5: 18}},
    3: {'cpu': 1, 'memory': 2, 'bandwidth': 10, 'execution_time': {1: 8, 2: 10, 3: 6, 4: 9, 5: 11}},
    4: {'cpu': 3, 'memory': 6, 'bandwidth': 15, 'execution_time': {1: 15, 2: 25, 3: 12, 4: 18, 5: 20}},
    5: {'cpu': 2, 'memory': 3, 'bandwidth': 25, 'execution_time': {1: 11, 2: 18, 3: 9, 4: 14, 5: 16}},
    6: {'cpu': 5, 'memory': 10, 'bandwidth': 40, 'execution_time': {1: 20, 2: 30, 3: 15, 4: 25, 5: 28}},
    7: {'cpu': 1, 'memory': 1, 'bandwidth': 5, 'execution_time': {1: 5, 2: 8, 3: 4, 4: 7, 5: 9}},
    8: {'cpu': 3, 'memory': 5, 'bandwidth': 18, 'execution_time': {1: 14, 2: 22, 3: 11, 4: 17, 5: 19}},
    9: {'cpu': 2, 'memory': 7, 'bandwidth': 22, 'execution_time': {1: 13, 2: 17, 3: 10, 4: 16, 5: 15}},
    10: {'cpu': 4, 'memory': 9, 'bandwidth': 35, 'execution_time': {1: 18, 2: 28, 3: 14, 4: 22, 5: 25}}
}

POPULATION_SIZE = 100  # Number of solutions in each generation
GENERATIONS = 200      # Number of iterations
MUTATION_RATE = 0.1    # Probability of a random mutation
ELITISM = 0.1          # Percentage of top individuals retained each generation

# Randomly initializes the population of schedules, respecting node constraints
def initialize_population():
    population = []
    for _ in range(POPULATION_SIZE):
        schedule = {}
        for task in tasks:
            valid_nodes = [node for node in nodes if
                tasks[task]['cpu'] <= nodes[node]['cpu'] * resource_limits['cpu'] and
                tasks[task]['memory'] <= nodes[node]['memory'] * resource_limits['memory'] and
                tasks[task]['bandwidth'] <= nodes[node]['bandwidth'] * resource_limits['bandwidth']]
            schedule[task] = random.choice(valid_nodes) if valid_nodes else random.choice(list(nodes))
        population.append(schedule)
    return population

# Calculates total CPU, memory, and bandwidth usage per node for a given schedule
def calculate_resource_usage(schedule):
    usage = {node: {'cpu': 0, 'memory': 0, 'bandwidth': 0} for node in nodes}
    for task, node in schedule.items():
        usage[node]['cpu'] += tasks[task]['cpu']
        usage[node]['memory'] += tasks[task]['memory']
        usage[node]['bandwidth'] += tasks[task]['bandwidth']
    return usage

# Checks whether a schedule respects all node constraints
def is_valid_schedule(schedule):
    usage = calculate_resource_usage(schedule)
    return all(
        usage[node]['cpu'] <= nodes[node]['cpu'] * resource_limits['cpu'] and
        usage[node]['memory'] <= nodes[node]['memory'] * resource_limits['memory'] and
        usage[node]['bandwidth'] <= nodes[node]['bandwidth'] * resource_limits['bandwidth']
        for node in nodes
    )

# Calculates the makespan: the highest total time spent on any one node
def calculate_makespan(schedule):
    if not is_valid_schedule(schedule):
        return float('inf')
    node_times = {node: 0 for node in nodes}
    for task, node in schedule.items():
        node_times[node] += tasks[task]['execution_time'][node]
    return max(node_times.values())

# Measures average resource utilization across all nodes
def calculate_resource_utilization(schedule):
    usage = calculate_resource_usage(schedule)
    total_util = 0
    for node in nodes:
        cpu_u = usage[node]['cpu'] / (nodes[node]['cpu'] * resource_limits['cpu'])
        mem_u = usage[node]['memory'] / (nodes[node]['memory'] * resource_limits['memory'])
        bw_u = usage[node]['bandwidth'] / (nodes[node]['bandwidth'] * resource_limits['bandwidth'])
        total_util += (cpu_u + mem_u + bw_u) / 3
    return total_util / len(nodes)

# Combines makespan and utilization into a fitness score
def fitness_function(schedule):
    makespan = calculate_makespan(schedule)
    if makespan == float('inf'):
        return 0
    utilization = calculate_resource_utilization(schedule)
    return 0.7 * (1 / makespan) + 0.3 * utilization

# Selects individuals for crossover using tournament selection
def selection(pop, scores):
    return [max(random.sample(list(zip(pop, scores)), 3), key=lambda x: x[1])[0] for _ in range(len(pop))]

# Performs one-point crossover between two parents
def crossover(p1, p2):
    point = random.randint(1, len(tasks) - 1)
    keys = list(tasks.keys())
    return {task: (p1[task] if i < point else p2[task]) for i, task in enumerate(keys)}

# Randomly mutates a task's node assignment
def mutation(schedule):
    child = deepcopy(schedule)
    task = random.choice(list(tasks))
    valid_nodes = [node for node in nodes if
        tasks[task]['cpu'] <= nodes[node]['cpu'] * resource_limits['cpu'] and
        tasks[task]['memory'] <= nodes[node]['memory'] * resource_limits['memory'] and
        tasks[task]['bandwidth'] <= nodes[node]['bandwidth'] * resource_limits['bandwidth']]
    if valid_nodes:
        child[task] = random.choice(valid_nodes)
    return child

# Runs the full genetic algorithm loop
def genetic_algorithm():
    population = initialize_population()
    best_fit = -1
    best_schedule = None
    fitness_progress = []

    for _ in range(GENERATIONS):
        scores = [fitness_function(ind) for ind in population]
        best = max(zip(population, scores), key=lambda x: x[1])
        if best[1] > best_fit:
            best_schedule, best_fit = best

        fitness_progress.append(best[1])
        elite_count = int(ELITISM * POPULATION_SIZE)
        elites = [ind for ind, _ in sorted(zip(population, scores), key=lambda x: x[1], reverse=True)[:elite_count]]
        selected = selection(population, scores)
        children = elites.copy()
        while len(children) < POPULATION_SIZE:
            p1, p2 = random.sample(selected, 2)
            child = crossover(p1, p2)
            if random.random() < MUTATION_RATE:
                child = mutation(child)
            children.append(child)
        population = children

    return best_schedule, fitness_progress

# Implements a deterministic round-robin assignment of tasks to nodes
def round_robin_schedule():
    schedule = {}
    node_ids = list(nodes)
    for i, task in enumerate(tasks):
        schedule[task] = node_ids[i % len(node_ids)]
    return schedule

# Run both GA and round-robin schedules
best_schedule, fitness_evolution = genetic_algorithm()
rr_schedule = round_robin_schedule()

# Output the best GA schedule and compare it to round-robin
print("\nBest Schedule (GA):")
for task, node in best_schedule.items():
    print(f"Task {task} → Node {node}")
print("Makespan:", calculate_makespan(best_schedule))
print("Utilization:", calculate_resource_utilization(best_schedule))

print("\nRound-Robin Schedule:")
for task, node in rr_schedule.items():
    print(f"Task {task} → Node {node}")
print("Makespan:", calculate_makespan(rr_schedule))
print("Utilization:", calculate_resource_utilization(rr_schedule))